import argparse
import os
import time # ADDED: Import time for timing measurements

# Local Imports
import config
import image_analyzer
import voice_selector
import data_manager # Although used by voice_selector, keep import for clarity if needed
import utils
import traceback # ADDED: For more robust error printing

# --- Dynamic TTS Module Import ---
try:
    if config.TTS_PROVIDER == 'elevenlabs':
        from tts_elevenlabs import synthesize as synthesize_speech
        print("Using ElevenLabs TTS backend.")
    elif config.TTS_PROVIDER == 'google':
        from tts_google import synthesize as synthesize_speech
        print("Using Google TTS backend.")
    elif config.TTS_PROVIDER == 'openai':
        from tts_openai import synthesize as synthesize_speech
        print("Using Openai TTS backend.")
    elif config.TTS_PROVIDER == 'gemini_tts':
        from tts_gemini import synthesize as synthesize_speech
        print("Using Openai TTS backend.")
    else:
        # This case is redundant due to config check, but good practice
        raise ImportError(f"TTS Provider '{config.TTS_PROVIDER}' is not supported.")
except ImportError as e:
    print(f"Error importing TTS module for provider '{config.TTS_PROVIDER}': {e}")
    print("Please ensure the corresponding TTS module (e.g., tts_elevenlabs.py) exists and required libraries are installed.")
    exit(1)
except Exception as e:
    print(f"An unexpected error occurred during TTS module import: {e}")
    exit(1)

# --- Main Execution ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process screenshot, map character to voice, speak dialogue.")
    parser.add_argument("image_path", help="Path to the screenshot image file.")
    parser.add_argument(
        "-o", "--output",
        help="Optional: Save the generated audio to this file path (e.g., output.mp3). Directory will be created if needed.",
        default=None
        )
    args = parser.parse_args()

    # Validate image path early
    if not os.path.exists(args.image_path) or not os.path.isfile(args.image_path):
        print(f"Error: Image file not found or is not a file: {args.image_path}")
        exit(1)

    print("-" * 30)
    print("Starting Main Orchestrator Pipeline...")

    pipeline_start_time = time.perf_counter() # Start timing the pipeline itself

    # --- Initialize Voice Selector ---
    t_start_init = time.perf_counter()
    # Uses paths from config
    vs = voice_selector.VoiceSelector(config.VOICES_PATH, config.MAPPING_PATH)
    vs.load_data() # Load voices.json and character_voices.json
    t_end_init = time.perf_counter()
    init_duration = t_end_init - t_start_init
    print(f"  [Time] Initialization: {init_duration:.3f} seconds")


    # --- Process Screenshot ---
    t_start_gemini = time.perf_counter()
    character_info = image_analyzer.get_info_from_screenshot(args.image_path)
    t_end_gemini = time.perf_counter()
    gemini_duration = t_end_gemini - t_start_gemini
    print(f"  [Time] Gemini Analysis + Persona Gen: {gemini_duration:.3f} seconds")

    synthesis_triggered = False
    tts_duration = 0.0
    select_duration = 0.0
    selected_voice_id = None
    stored_persona = "" # Initialize stored_persona

    if character_info:
        char_name = character_info.get("character_name", "Unknown")
        gender = character_info.get("gender", "Unknown")
        dialogue = character_info.get("dialogue", "")
        # ADDED: Get the persona generated by Gemini in this run
        generated_persona = character_info.get("persona_instructions", "")


        print("\n--- Extracted Information ---")
        print(f"Character Name: {char_name}")
        print(f"Gender: {gender}")
        print(f"Dialogue: '{dialogue}'")
        if generated_persona:
             # Only show a snippet of the potentially long persona
             persona_snippet = (generated_persona[:70] + '...') if len(generated_persona) > 70 else generated_persona
             print(f"Generated Persona: '{persona_snippet}'")
        print("---------------------------\n")


        # --- Get Voice ID (Local Logic) ---
        t_start_select = time.perf_counter()
        # MODIFIED: Pass generated_persona and capture both voice_id and stored_persona
        selected_voice_id, stored_persona = vs.find_or_assign_voice(
            char_name,
            gender,
            generated_persona # Provide the freshly generated persona
        )
        t_end_select = time.perf_counter()
        select_duration = t_end_select - t_start_select
        print(f"  [Time] Voice Selection & Persona Store/Retrieve: {select_duration:.4f} seconds")


        # --- Speak Dialogue ---
        if dialogue:
            if selected_voice_id:
                synthesis_triggered = True
                print(f"[Pipeline] Starting TTS Synthesis + Playback (Voice ID: {selected_voice_id})...")

                # Prepare keyword arguments for synthesize_speech
                synthesis_kwargs = {
                    "text": dialogue,
                    "voice_id": selected_voice_id,
                    "output_filename": args.output
                }

                # ADDED: Add 'instructions' ONLY if using OpenAI/gemini AND a persona exists for this char
                if config.TTS_PROVIDER == 'openai' or config.TTS_PROVIDER == 'gemini-tts':
                    if stored_persona:
                        synthesis_kwargs["instructions"] = stored_persona
                        print(f"  -> Providing stored {config.TTS_PROVIDER} TTS persona instructions.")
                    else:
                        print(f"  -> No stored persona found for '{char_name}'. Synthesizing with default delivery.")

                t_start_tts = time.perf_counter()
                try:
                    success = synthesize_speech(**synthesis_kwargs)
                except TypeError as te:
                     # Added robust error handling for missing 'instructions' argument
                     if 'instructions' in str(te) and config.TTS_PROVIDER == 'openai':
                          print(f"  [Error] Your tts_openai.py's synthesize function needs to accept the 'instructions' argument.")
                          print("          Please update tts_openai.py. Attempting synthesis without instructions...")
                          synthesis_kwargs.pop('instructions', None) # Remove the problematic arg
                          success = synthesize_speech(**synthesis_kwargs)
                     elif 'instructions' in str(te):
                          # Provider isn't OpenAI, but somehow instructions were passed? Ignore.
                           synthesis_kwargs.pop('instructions', None)
                           success = synthesize_speech(**synthesis_kwargs)
                     else:
                          raise # Re-raise other TypeErrors
                except Exception as synth_e:
                     print(f"  [Error] An unexpected error occurred during synthesis: {synth_e}")
                     traceback.print_exc() # Print full traceback for unexpected errors
                     success = False

                t_end_tts = time.perf_counter()
                tts_duration = t_end_tts - t_start_tts
                print(f"  [Time] TTS Synthesis + Playback/Save (Total): {tts_duration:.3f} seconds")
                if not success:
                    print("[Pipeline] Failed to synthesize or play/save audio.")
            else:
                print("[Pipeline] Error: Could not determine a voice ID (including fallback). Cannot speak dialogue.")
        else:
            print("[Pipeline] No dialogue found in the screenshot to speak.")

        # --- Save Mapping if Updated ---
        vs.save_map() # Saves the map if find_or_assign_voice updated it

    else:
        print("Failed to get character information from the screenshot.")

    pipeline_end_time = time.perf_counter()
    total_pipeline_duration = pipeline_end_time - pipeline_start_time

    print("-" * 30)
    print("[Timing Summary]")
    print(f"  - Initialization:        {init_duration:.3f} s")
    print(f"  - Gemini Analysis+Persona: {gemini_duration:.3f} s")
    if character_info:
      print(f"  - Voice Select/Persona:  {select_duration:.4f} s")
      if synthesis_triggered:
          print(f"  - TTS + Playback/Save: {tts_duration:.3f} s")
      else:
          print(f"  - TTS + Playback/Save: N/A")
    print(f"  - Total Pipeline Time:   {total_pipeline_duration:.3f} s")
    print("-" * 30)

    print("\nScript finished.")